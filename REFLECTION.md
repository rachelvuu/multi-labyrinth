[Kevin]
At the beginning of the project. It was difficult looking over the labyrinth because the code was distributed over many files which showed that used single responsibility. This echoed throughout our project as we needed to make several methods and separating them. We saw that the previous version had unused methods or classes that didn’t need to be project. We decided to implement the controller from model view controller. Having a player controller allows the abstract class to be understandable and allows to understand the functionality of the class when looking through the code. 

As we collaborated code, I shared that server should maintain the unique ids and updating the clients by running the game based on the ID of the player. This ended up being scrapped and now involves running the game based on the client that is added to the server without the need of the ID. This allows for less confusion favors composition over inheritance of utilizing the ID’s. Overall a difficult project to manage with four people that struggles to allow voices to be heard as design implementation and figuring out how to tackle the code can be easily lost if not properly communicated. Furthermore, their implementations functioned better with the code but in the future there needs to be laid out constraints for the team and understanding what design pattern we want to keep in mind when working on the project.

[Rachel]
In my original code from assignment 2, my partner and I did not implement the extensibility requirement of specifying our labyrinth in a .json file. As a result, we utilized another group member’s code for this assignment. Working with their solution gave me a better understanding of keeping components abstract which made expanding the labyrinth itself much simpler for this assignment. This required almost no modification since interfaces and abstract classes were used to characterize components as movable players, hazards or items. 

Adapting a model-view-controller style to this assignment strengthened my grasp of the style itself as well as add the client-server functionality. In our code, the server model (the map) updates the client. The client has its own controller to determine what command to send and so does the server (the game class). Modifying the program to follow MVC affords this asynchronous communication and helped us manage the separation of functionality for a larger scale labyrinth. The most important takeaway from reflecting on my own original design choices is to stress separation of concerns. We had only 2 files with functions outside of classes, scattered and high concentrations of responsibilities, and a heavily detailed approach, which collectively made the program unsalvageable for homework 4. When developing software in the future I would give higher prioritization to constraints, especially extendability, before deciding on a style. 
